# My awesome bash prompt
#
# Based on cowboy's prompt:
# https://github.com/cowboy/dotfiles/blob/master/source/50_prompt.sh
#
# Inspiration from mathiasbynens' prompt:
# https://github.com/mathiasbynens/dotfiles/blob/master/.bash_prompt

# Example:
# rowno at rowno-thinkpad in ~/projects/dotfiles on master:!?
# 21:24:42 $

# ANSI CODES - SEPARATE MULTIPLE VALUES WITH ;
#
#  0  reset          4  underline
#  1  bold           7  inverse
#
# FG  BG  COLOR     FG  BG  COLOR
# 30  40  black     34  44  blue
# 31  41  red       35  45  magenta
# 32  42  green     36  46  cyan
# 33  43  yellow    37  47  white

if [[ ! "${prompt_colors[@]}" ]]; then
    prompt_colors=(
        "1;33" # information color
        "1;37" # bracket color
        "1;31" # error color
    )

    if [[ "$SSH_TTY" ]]; then
        # connected via ssh
        prompt_colors[0]="1;32"
    elif [[ "$USER" == "root" ]]; then
        # logged in as root
        prompt_colors[0]="1;35"
    fi
fi

# Inside a prompt function, run this alias to setup local $c0-$c9 color vars.
alias prompt_getcolors='prompt_colors[9]=; local i; for i in ${!prompt_colors[@]}; do local c$i="\[\e[0;${prompt_colors[$i]}m\]"; done'

# Exit code of previous command.
function prompt_exitcode() {
    prompt_getcolors
    [[ $1 != 0 ]] && echo " $c2$1$c9"
}

# Git status.
function prompt_git() {
    prompt_getcolors
    local status output flags
    status="$(git status 2>/dev/null)"
    [[ $? != 0 ]] && return;
    output="$(echo "$status" | awk '/# Initial commit/ {print "init"}')"
    [[ "$output" ]] || output="$(__git_ps1 | perl -ne '/\(+(.*?)\)+/ && print $1')"
    flags="$(
        echo "$status" | awk 'BEGIN {r=""} \
            /^# Changes to be committed:$/        {r=r "+"}\
            /^# Changes not staged for commit:$/  {r=r "!"}\
            /^# Untracked files:$/                {r=r "?"}\
            END {print r}'
    )"
    if [[ "$flags" ]]; then
        output="$output$c1:$c0$flags"
    fi
    echo "$c1 on $c0$output$c9"
}

# SVN info.
function prompt_svn() {
    prompt_getcolors
    local info="$(svn info . 2> /dev/null)"
    local last current
    if [[ "$info" ]]; then
        last="$(echo "$info" | awk '/Last Changed Rev:/ {print $4}')"
        current="$(echo "$info" | awk '/Revision:/ {print $2}')"
        echo "$c0$last$c1:$c0$current$c9"
    fi
}

# Maintain a per-execution call stack.
prompt_stack=()
trap 'prompt_stack=("${prompt_stack[@]}" "$BASH_COMMAND")' DEBUG

function prompt_command() {
    local exit_code=$?
    # If the first command in the stack is prompt_command, no command was run.
    # Set exit_code to 0 and reset the stack.
    [[ "${prompt_stack[0]}" == "prompt_command" ]] && exit_code=0
    prompt_stack=()

    # Manually load z here, after $? is checked, to keep $? from being clobbered.
    [[ "$(type -t _z)" ]] && _z --add "$(pwd -P 2>/dev/null)" 2>/dev/null

    # While the simple_prompt environment var is set, disable the awesome prompt.
    [[ "$simple_prompt" ]] && PS1='\n$ ' && return

    prompt_getcolors
    # http://twitter.com/cowboy/status/150254030654939137
    PS1="\n"
    # misc: [cmd#:hist#]
    # PS1="$PS1$c1[$c0#\#$c1:$c0!\!$c1]$c9"
    # path: user at host in path
    PS1="$PS1$c0\u$c1 at $c0\h$c1 in $c0\w$c9"
    # svn: [repo:lastchanged]
    PS1="$PS1$(prompt_svn)"
    # git: [branch:flags]
    PS1="$PS1$(prompt_git)"
    PS1="$PS1\n"
    # date: HH:MM:SS
    PS1="$PS1$c0$(date +"%H$c1:$c0%M$c1:$c0%S")$c9"
    # exit code: 127
    PS1="$PS1$(prompt_exitcode "$exit_code")"
    PS1="$PS1$c1 \$ $c9"
}

PROMPT_COMMAND="prompt_command"
